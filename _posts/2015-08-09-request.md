---
layout: post
title: DraweeView分析
category : fresco
tagline: "Supporting tagline"
tags : [fresco, android]
---
{% include JB/setup %}
#Fresco Http请求
Fresco的请求是在哪里发起的呢,现在来看一下:

    DraweeController draweeController = Fresco.newDraweeControllerBuilder()
           .setImageRequest(imageRequest)
           .setOldController(view.getController())
           .setControllerListener(view.getListener())
           .setAutoPlayAnimations(true)
           .build();

---
<!--break-->
要想找到Fresco的请求是在哪里发起的,必须先来看一下```DraweeController```的初始化,因为```DataSource```是在这里来创建的,上面的代码创建了一个```DraweeController```,这里返回的是一个```AbstractDraweeController```的实例,先来看```newDraweeControllerBuilder()```这个方法

    /** Returns a new instance of Fresco Drawee controller builder. */
     public static PipelineDraweeControllerBuilder newDraweeControllerBuilder() {
       return sDraweeControllerBuilderSupplier.get();
     }

这个方法返回了一个```PipelineDraweeControllerBuilder```,方法调用了一个get()方法

    @Override
    public PipelineDraweeControllerBuilder get() {
        return new PipelineDraweeControllerBuilder(
            mContext,
            mPipelineDraweeControllerFactory,
            mImagePipeline,
            mBoundControllerListeners);
    }

随后是```setImageRequest()```

    /** Sets the image request. */
    public BUILDER setImageRequest(REQUEST imageRequest) {
      mImageRequest = imageRequest;
      return getThis();
    }

```setImageRequest()```返回的是BUILDER的类型,这个BUILDER是一个范型类型,这个类型是```PipelineDraweeControllerBuilder```,最后调用```build()```,看一下```build()```实现


    /** Builds a regular controller. */
    protected AbstractDraweeController buildController() {
      AbstractDraweeController controller = obtainController();
      maybeBuildAndSetRetryManager(controller);
      maybeAttachListeners(controller);
      return controller;
    }

这里调用了```obtainController```的方法,这里是在子类```PipelineDraweeController```里实现的

    @Override
    protected PipelineDraweeController obtainController() {
      DraweeController oldController = getOldController();
      PipelineDraweeController controller;
      if (oldController instanceof PipelineDraweeController) {
        controller = (PipelineDraweeController) oldController;
        controller.initialize(
            obtainDataSourceSupplier(),
            generateUniqueControllerId(),
            getCallerContext());
      } else {
        controller = mPipelineDraweeControllerFactory.newController(
            obtainDataSourceSupplier(),
            generateUniqueControllerId(),
            getCallerContext());
      }
      return controller;
    }

这里调用了```obtainDataSourceSupplier```的方法,这个方法最终调用的是

    @Override
    protected DataSource<CloseableReference<CloseableImage>> getDataSourceForRequest(
        ImageRequest imageRequest,
        Object callerContext,
        boolean bitmapCacheOnly) {
      if (bitmapCacheOnly) {
        return mImagePipeline.fetchImageFromBitmapCache(imageRequest, callerContext);
      } else {
        return mImagePipeline.fetchDecodedImage(imageRequest, callerContext);
      }
    }

这个方法来创建```DataSource```,这里是真正发送的请求,如果是缓存的会去读取硬盘的缓存,如果不是的话就会发送一个http请求来获取图片,现在就该到了ImagePipeline的模块了,看一下```fetchDecodedImage```方法.

    /**
     * Submits a request for execution and returns a DataSource representing the pending decoded
     * image(s).
     *
     * <p>The returned DataSource must be closed once the client has finished with it.
     * @param imageRequest the request to submit
     * @return a DataSource representing the pending decoded image(s)
     */
    public DataSource<CloseableReference<CloseableImage>> fetchDecodedImage(
        ImageRequest imageRequest,
        Object callerContext) {
      try {
        Producer<CloseableReference<CloseableImage>> producerSequence =
            mProducerSequenceFactory.getDecodedImageProducerSequence(imageRequest);
        return submitFetchRequest(
            producerSequence,
            imageRequest,
            ImageRequest.RequestLevel.FULL_FETCH,
            callerContext);
      } catch (Exception exception) {
        return DataSources.immediateFailedDataSource(exception);
      }
    }

这个方法的解释:返回一个```DataSource```一旦完成必须关闭它.方法中调用了```mProducerSequenceFactory.getDecodedImageProducerSequence()```方法.看一下这个方法和```Producer```的作用.

    /**
     * Returns a sequence that can be used for a request for a decoded image.
     *
     * @param imageRequest the request that will be submitted
     * @return the sequence that should be used to process the request
     */
    public Producer<CloseableReference<CloseableImage>> getDecodedImageProducerSequence(
        ImageRequest imageRequest) {
      Producer<CloseableReference<CloseableImage>> pipelineSequence =
          getBasicDecodedImageSequence(imageRequest);
      if (imageRequest.getPostprocessor() != null) {
        return getPostprocessorSequence(pipelineSequence);
      } else {
        return pipelineSequence;
      }
    }

这个方法返回一个请求和解析图片的对列.然后调用```getBasicDecodedImageSequence```根据uri来返回不同的```Producer```的实例,这个uri可以是network,file,contentprovider,assert,Resources类型的,如果不是这几种类型会抛出一个运行时异常,回到```fetchDecodedImage```方法,返回```Producer```之后会调用```submitFetchRequest```方法,看一下这个方法的实现

    private <T> DataSource<CloseableReference<T>> submitFetchRequest(
        Producer<CloseableReference<T>> producerSequence,
        ImageRequest imageRequest,
        ImageRequest.RequestLevel lowestPermittedRequestLevelOnSubmit,
        Object callerContext) {
      try {
        ImageRequest.RequestLevel lowestPermittedRequestLevel =
            ImageRequest.RequestLevel.getMax(
                imageRequest.getLowestPermittedRequestLevel(),
                lowestPermittedRequestLevelOnSubmit);
        SettableProducerContext settableProducerContext = new SettableProducerContext(
            imageRequest,
            generateUniqueFutureId(),
            mRequestListener,
            callerContext,
            lowestPermittedRequestLevel,
          /* isPrefetch */ false,
            imageRequest.getProgressiveRenderingEnabled() ||
                !UriUtil.isNetworkUri(imageRequest.getSourceUri()),
            imageRequest.getPriority());
        return CloseableProducerToDataSourceAdapter.create(
            producerSequence,
            settableProducerContext,
            mRequestListener);
      } catch (Exception exception) {
        return DataSources.immediateFailedDataSource(exception);
      }
    }

这里返回了一个```CloseableProducerToDataSourceAdapter```类型.因为```CloseableProducerToDataSourceAdapter```是```DataSource```类型的,创建```CloseableProducerToDataSourceAdapter```的时候调用了一个方法```producer.produceResults(createConsumer(), settableProducerContext);```这里的producer如果第一次请求是```NetworkFetcherProducer```如果是已经缓存的
则是```DiskCacheProducer```.
先看看```NetworkFetcherProducer```这个类的```produceResults```这个方法

    @Override
      public void produceResults(Consumer<EncodedImage> consumer, ProducerContext context) {
        context.getListener()
            .onProducerStart(context.getId(), PRODUCER_NAME);
        final FetchState fetchState = mNetworkFetcher.createFetchState(consumer, context);
        mNetworkFetcher.fetch(
            fetchState, new NetworkFetcher.Callback() {
              @Override
              public void onResponse(InputStream response, int responseLength) throws IOException {
                NetworkFetchProducer.this.onResponse(fetchState, response, responseLength);
              }

              @Override
              public void onFailure(Throwable throwable) {
                NetworkFetchProducer.this.onFailure(fetchState, throwable);
              }

              @Override
              public void onCancellation() {
                NetworkFetchProducer.this.onCancellation(fetchState);
              }
            });

这里又涉及到两个类```NetworkFetcher```和```Consumer```,这里的```NetworkFetcher```有两个子类```OkHttpNetworkFetcher```和```HttpUrlConnectionNetworkFetcher```如果使用okhttp这个框架则会使用```OkHttpNetworkFetcher```,如果没有则直接使用```HttpUrlConnectionNetworkFetcher```,我们只看```OkHttpNetworkFetcher```这个类.
这里最主要的还是```fetch()```这个方法,这个方法会使用OkHttp创建一个http请求,如果请求成功会调用callback.onResponse把InputStream和图片的长度回调到```NetworkFetchProducer```的onResponse方法中.

    private void onResponse(
          FetchState fetchState,
          InputStream responseData,
          int responseContentLength)
          throws IOException {
        final PooledByteBufferOutputStream pooledOutputStream;
        if (responseContentLength > 0) {
          pooledOutputStream = mPooledByteBufferFactory.newOutputStream(responseContentLength);
        } else {
          pooledOutputStream = mPooledByteBufferFactory.newOutputStream();
        }
        final byte[] ioArray = mByteArrayPool.get(READ_SIZE);
        try {
          int length;
          while ((length = responseData.read(ioArray)) >= 0) {
            if (length > 0) {
              pooledOutputStream.write(ioArray, 0, length);
              maybeHandleIntermediateResult(pooledOutputStream, fetchState);
              float progress = calculateProgress(pooledOutputStream.size(), responseContentLength);
              fetchState.getConsumer().onProgressUpdate(progress);
            }
          }
          mNetworkFetcher.onFetchCompletion(fetchState, pooledOutputStream.size());
          handleFinalResult(pooledOutputStream, fetchState);
        } finally {
          mByteArrayPool.release(ioArray);
          pooledOutputStream.close();
        }

上面是```NetworkFetchProducer```的onResponse方法,这里会更新图片的进度,最后会调用```handleFinalResult```方法.这里面又涉及一个类```PooledByteBufferOutputStream```这个类是从native空间中开辟内存的.

    private void handleFinalResult(
        PooledByteBufferOutputStream pooledOutputStream,
        FetchState fetchState) {
      Map<String, String> extraMap = getExtraMap(fetchState, pooledOutputStream.size());
      fetchState.getListener()
          .onProducerFinishWithSuccess(fetchState.getId(), PRODUCER_NAME, extraMap);
      notifyConsumer(pooledOutputStream, true, fetchState.getConsumer());
    }

    private void notifyConsumer(
        PooledByteBufferOutputStream pooledOutputStream,
        boolean isFinal,
        Consumer<EncodedImage> consumer) {
      CloseableReference<PooledByteBuffer> result =
          CloseableReference.of(pooledOutputStream.toByteBuffer());
      EncodedImage encodedImage = null;
      try {
        encodedImage = new EncodedImage(result);
        consumer.onNewResult(encodedImage, isFinal);
      } finally {
        EncodedImage.closeSafely(encodedImage);
        CloseableReference.closeSafely(result);
      }
    }

这里会调用```consumer.onNewResult()```方法,这里一定要关闭引用.这个consumer哪里来的呢.其实是在```AbstractProducerToDataSourceAdapter```的构造方法里producer.produceResults(createConsumer(), settableProducerContext)传递过来的.现在在回到这个类来看一下.

    protected void onNewResultImpl(@Nullable T result, boolean isLast) {
      if (super.setResult(result, isLast)) {
        if (isLast) {
          mRequestListener.onRequestSuccess(
              mSettableProducerContext.getImageRequest(),
              mSettableProducerContext.getId(),
              mSettableProducerContext.isPrefetch());
        }
      }
    }

这是回调过来调用的方法,这是的mRequestListener是```ForwardingRequestListener```的实例,这里会调用super.setResult方法.

    protected boolean setResult(@Nullable T value, boolean isLast) {
      boolean result = setResultInternal(value, isLast);
      if (result) {
        notifyDataSubscribers();
      }
      return result;
    }

这个方法会调用```notifyDataSubscribers```来通知图片下载完成.这个相当于观察者模式.看下```notifyDataSubscribers```方法

    private void notifyDataSubscribers() {
      final boolean isFailure = hasFailed();
      final boolean isCancellation = wasCancelled();
      for (Pair<DataSubscriber<T>, Executor> pair : mSubscribers) {
        notifyDataSubscriber(pair.first, pair.second, isFailure, isCancellation);
      }
    }

    private void notifyDataSubscriber(
        final DataSubscriber<T> dataSubscriber,
        final Executor executor,
        final boolean isFailure,
        final boolean isCancellation) {
      executor.execute(
          new Runnable() {
            @Override
            public void run() {
              if (isFailure) {
                dataSubscriber.onFailure(AbstractDataSource.this);
              } else if (isCancellation) {
                dataSubscriber.onCancellation(AbstractDataSource.this);
              } else {
                dataSubscriber.onNewResult(AbstractDataSource.this);
              }
            }
          });
    }

最后会回调到哪里呢.这里会回调到```AbstractDraweeController```的```submitRequest```方法中.这样下载图片的流程就完成了.在调用```DraweeHierarchy```的```setImage```图片就显示完成了.
在来看看如何写缓存的.还得回到```producerSequenceFactory```的```getNetworkFetchSequence()```方法,这个方法里又调用了```getCommonNetworkFetchToEncodedMemorySequence()```
内存缓存和硬盘缓存都是在这个方法里初始化的.
